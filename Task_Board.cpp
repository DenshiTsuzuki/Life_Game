#pragma once
#include "Task_Board.h"

namespace Board {
	//生成
	Resorce::WP Resorce::instance;
	//-----------------------------------------------------------------------------------
	//								リソースコンストラクタ！
	//-----------------------------------------------------------------------------------
	Resorce::Resorce() 
	{

	}


	//-----------------------------------------------------------------------------------
	//								リソースデストラクタ！
	//-----------------------------------------------------------------------------------
	Resorce::~Resorce() 
	{


	}

	//-----------------------------------------------------------------------------------
	//							生成時　初期化
	//-----------------------------------------------------------------------------------
	void Object::Init()
	{
		//優先度変更

		//生成時状態変更


		//変数初期化
		memset(this->_arr,0, sizeof(_arr));

		//計算結果用
		memset(_cpy_arr, 0, sizeof(_cpy_arr));

		//初期値を与える
		for (int y = 0; y < _arrLeg_Y;++y) {
			for (int x = 0;x < _arrLeg_X;++x) {
				this->_arr[y][x] = Random(0, 1);
			}
		}

		//正方形
		this->_size = 20;

		//カウンタ
		this->_cnt = 0;

	}
	//-----------------------------------------------------------------------------------
	//							更新処理
	//-----------------------------------------------------------------------------------
	void Object::Update()
	{
		++this->_cnt;
		//20フレームに一度実行
		if (this->_cnt < 30) return;
 
		//ライフゲーム部分
		for (int y = 0;y < _arrLeg_Y;++y) {
			for (int x = 0;x < _arrLeg_X;++x) {
				 
				int check = this->CheckAround(x, y);

				//対象セル
				switch (this->_arr[y][x]){
				case 0://死んでいる場合
					//周りに生きているセルがちょうど３つなら繁殖
					if (check == 3) { this->_cpy_arr[y][x] = 1; }
					break;

				case 1://生きている場合
					//周りの生きているセルが2or3なら生存
					if (check == 2 || check == 3) { this->_cpy_arr[y][x] = 1; }
					break;
				}
			}
		}

		memcpy(this->_arr, _cpy_arr, sizeof(_cpy_arr));

		//コピー終了で初期化
		memset(_cpy_arr, 0, sizeof(_cpy_arr));

		//実行終了時カウンタを0に！
		this->_cnt = 0;
	}

	//-----------------------------------------------------------------------------------
	//							描画処理
	//-----------------------------------------------------------------------------------
	void Object::Draw()
	{
		for (int y = 0;y < _arrLeg_Y;++y) {
			for (int x = 0;x < _arrLeg_X;++x) {
				Rect(x * _size, y * _size, _size).drawFrame(0, 1, Palette::Indigo);
				//生存していない
				if (this->_arr[y][x] == 0)continue;
				
				//生存中
				Rect(x * _size, y * _size, _size).draw(Palette::Maroon);
			}
		}
	}

	int Object::CheckAround(int x_, int y_)
	{
		//周囲の数を変えす
		int sum = 0;

		//3*3で周囲を見る
		for (int y = -1;y < 2;++y) {
			for (int x = -1;x < 2;++x) {

				//範囲外チェック
				if (x_ + x < 0 || x_ + x >= _arrLeg_X ||
					y_ + y < 0 || y_ + y >= _arrLeg_Y) {
					continue;
				}

				//自分は判定しない
				if (x == 0 && y == 0) {
					continue;
				}

				//あるならplus
				if (this->_arr[y_ + y][x_ + x] > 0) {
					++sum;
				}

			}
		}
		return sum;
	}

	
	
	//-----------------------------------------------------------------------------------
	//						オブジェクトデストラクタ
	//-----------------------------------------------------------------------------------
	void Object::Finalize()
	{

	}
	//-----------------------------------------------------------------------------------
	//						タスク	デストラクタ
	//-----------------------------------------------------------------------------------
	Object::~Object()
	{

	}




	//-----------------------------------------------------------------------------------
	// ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆
	//								基本的に変更必要なし
	//  ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆ ★☆★☆
	//-----------------------------------------------------------------------------------
	//-----------------------------------------------------------------------------------
	//						リソース　生成と確認
	//-----------------------------------------------------------------------------------
	Resorce::SP Resorce::Create()
	{
		//有無を確認
		auto sp = instance.lock();

		//無ければ生成
		if (!sp) {
			sp = Resorce::SP();
			instance = sp;
		}

		return sp;
	}

	//-----------------------------------------------------------------------------------
	//							オブジェクト生成　&& 初期化
	//-----------------------------------------------------------------------------------
	Object::SP Object::Create() {
		//タスク生成
		Object::SP obj = make_shared<Object>();

		//登録
		ML::Task_System.AddTask(obj);

		//初期化
		obj->Init();

		return obj;
	}

	//-----------------------------------------------------------------------------------
	//					タスク	オブジェクトコンストラクタ
	//-----------------------------------------------------------------------------------
	Object::Object() :
		BTask(defGroupName, defTaskName),
		res(Resorce::Create())
	{



	}

}